# [BOJ] 11000 - 강의실 배정

### 1. 구조

- 사용한 자료구조 : 우선순위 큐(힙)
- 사용한 알고리즘 : 그리디

영원히 그리디로 고통받는 인간 여기있음..

그리디 진짜진짜싫다. 이거땜에 정렬하는것도 짜증난다. 스케쥴링처럼 뭔가 특수한 문제에만 기가막히게 동작한다는 사실도 참 별로.

아무튼 정렬을 잘 해놓고 순간순간 최적해를 구하면 **O(n) 이라는 아주 좋은 시간복잡도**를 가지게 된다.

  

### 2. 알고리즘

(1) 벡터든 뭐든 정수 두 개를 한번에 받을 수 있는 자료구조를 둔다. (시작, 끝)

(2) 벡터를 시작 순서대로 정렬한다.

(3) 첫번째 끝나는 시간을 오름차순 우선순위 큐에 넣는다.

(4) 우선순위 큐에서 하나 뽑는다. 두번째의 시작시간과 비교한다.

​	(4-1) top()이 두번째 시작시간보다 작다면 (시간이 안겹친다면) -> 큐에서 뽑고 두번째 끝나는시간을 넣음.

​	(4-2) top()이 두번째 시작시간보다 크다면 (겹친다면) -> 그냥 두번째 끝나는 시간을 넣음.

(5) 이렇게 계속 먼저 끝날 회의실과 시간을 비교하다 보면 모든 시간을 다 돌게 된다.

(6) 마지막의 큐 사이즈가 곧 최소 회의실 갯수.

  



### 3. 코드

```c++
#include <iostream>
#include <queue>
using namespace std;

int n;
pair<int, int> t[200000];
priority_queue<int, vector<int>, greater<int>> pq;

int main()
{
    cin >> n;
    for(int i=0 ; i<n ; i++)
        cin >> t[i].first >> t[i].second;

    sort(t, t+n);
    pq.push(t[0].second);

    for(int i=1 ; i<n ; i++)
    {
        // 수업시간이 안겹치면
        if(pq.top() <= t[i].first)
        {
            pq.pop();
            pq.push(t[i].second);
        }
        // 겹치면
        else
        {
            pq.push(t[i].second);
        }
        
    }
    cout << pq.size();
    return 0;
}
```

